# 객체 리터럴

#### *3.프로퍼티 키와 값 정복하기*
###### -객체는 프로퍼티의 집합으로 프로퍼티는 키와 값으로 구성된다.  

```
1) 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
-식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 ""를 사용 but 식별자 네이밍 규칙을 준수하는 이름에는 ""를 생략가능
예) symbol은 문자열이므로 무조건 ""붙여야 하고  자바스크립트에서 사용가능한 유효한 이름인 경우 생략 가능.

2) 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값
```
**ex1)**
```javascript
var person = {
    name:'Lee',        //프로퍼티 키는 name, 프로퍼티 값은 'Lee'
    age:20             //프로퍼티 키는 age 프로퍼티 값은 20
};
```

#### *4.프로퍼티 특징*  
```
1) 프로퍼티 키를 동적으로 생성하는 걍우 프로퍼티 키로 사용할 표현식은 대괄호([...])로 묶어야 한다.

2) 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵전 타입 변환을 통해 문자열이 된다.

3) var, function과 같은 예약어를 프로퍼티 키로 사용해도 에러가 발생하지 않는다.

4) 존재하는 프로퍼티 키를 중복선언 하면 나중에 선언한 프로퍼티가 이전에 선언한 프로퍼티를 덮어쓴다.
```

#### *5.프로퍼티 접근방법*
```
1) 마침표 프로퍼티 접근 연산자
  ① 좌측: 객체로 평가되는 표현식
  ② 우측: 프로퍼티 키 지정

2) 대괄호 프로퍼티 접근 연산자
  ① 좌측: 객체로 평가되는 표현식
  ② 내부: 프로퍼티 키 지정 -> 반드시 ""(따옴표)로 감싼 문자열(따옴표로 감싸지 않으면 자바스크립트 엔진은 식별자로 해석함.)

※ 프로퍼티 키가 식별자 네이밍을 준수하는 이름이면 마침표 표기법, 대괄호 표기법 모두 사용 가능
※ 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환함.
```

#### *중간정리*  
지금까지 정리한 내용을 예제를 통하여 정리해보겠다.

```javascript
var person = {
    'last-name':'Lee',
    1:10
};

person.'last-name';
person.last-name;
person[last-name];
person['last-name'];


person.1;
person.'1';
person[1];
person['1'];
```

오류나는 이유 분석  
**1.person.'last-name';** => 오류 => 수정: person['last-name'];   
-객체 속성에 접근할 때는 마침표 표기법, [...]표기법을 사용해야함.      

**2.person.last-name;** => 오류 => 수정: person['last-name'];  
-객체 속성에 접근할 때는 대시(-)가 포함된 경우 마침표 표기법으로 접근할 수 없다.      

**3.person[last-name];** => 오류 => 수정: person['last-name'];  
-last-name이라는 변수가 선언되지 않았으며 대괄호 안에는 문자열 또는 변수가 와야하는데 변수로 해석되지 않아 오류가 발생한다.      

**4.person['last-name'];** => Lee 출력    
-객체 속성에 접근할 때 속성이름에 대괄호를 사용하여 문자열로 속성이름을 지정할 수 있다.      

**5.person.1;** => 오류 => 수정: person[1];  
-객체 속성 이름은 숫자로 시작할 수 없다.      

**6.person.'1';** => 오류 => 수정: person['1']  
-속성이름은 따옴표 안에 문자열로 지정되어야 한다.      

**7.person[1];** => 10 출력  
-객체 속성에 접근할 때 속성 이름에 대괄호를 사용하여 숫자로 된 속성 이름을 지정할 수 있다.    

**8.person['1'];** => 10 출력  
-객체 속성에 접근할 때 숫자로 된 속성이름을 문자열로 지정하여 접근

#### *6. 동적 속성 할당*
속성 이름이나 값이 코드 실행 중 결정됨. 즉, 실행 중에 변수 또는 표현식의 결과에 따라 결정됨.  

**계산된 프로퍼티 이름**  
문자열 또는 문장열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성 할 수 있다.  
프로퍼티 키로 사용할 표현식은 반드시 대괄호 ([...]) 안에 묶어야 하는데 이를 게산된 프로퍼티 이름이라 한다.

두 동적 속성 예제의 차이점을 분석해보자.  
**ex1)**
```javascript
var prefix ='prop';
var i=0;

var obj= {};

// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
obj[prefix + '-' + ++i]=i;
obj[prefix + '-' + ++i]=i;
obj[prefix + '-' + ++i]=i;

console.log(obj);
```
ex1) 코드 분석해보자

**1.var prefix ='prop';** - profix 변수 선언하고 초기화  
**2.var i=0;** - i 변수 선언하고 초기화  
**3.var obj= {};** - 빈 객체 obj 생성  
**4.obj[prefix + '-' + ++i]=i;** - prefix와 i를 사용하여 각각의 속성 이름과 값을 동적으로 할당

**ex2)**
```javascript
const prefix='prop';
let i=0;

// 객체 리터럴 내부에서 게산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성
const obj = {
    [`${prefix}-${++i}`]:i,
    [`${prefix}-${++i}`]:i,
    [`${prefix}-${++i}`]:i
};

console.log(obj);
```
ex2) 코드 분석해보자

**1.const prefix='prop';** - profix 변수 선언하고 초기화 (※ const는 상수를 선언할 때 사용하며 값이 변경되지 않음을 의미한다.)  
**2.let i=0;** - i 변수 선언하고 초기화 ( ※ let은 블록 범위 변수를 선언하는 키워드이다.)  
**3.const obj = {[`${prefix}-${++i}`]:i,}** -객체 생성, 속성이름과 값을 동적으로 할당하였고 템플릿 리터럴을 사용하여 동적으로 속성이름을 지정함.    

###### ex1)과 ex2)의 차이점  
```
1) 변수 선언 방법

2) 동적 속성 할당법
 ex1): 객체에 대한 속성을 동적으로 할당하기위해 대괄호 표기법 사용
 ex2): 템플릿 리터럴을 사용하여 속성이름을 동적으로 할당
  ```  
#### *7.프로퍼티 삭제*
delete 연산자를 이용하여 객체의 프로퍼티를 삭제한다.  
delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함.  
```javascript
var person = {
    name: 'Lee'
};

//프로퍼티 동적 생성
person.age=20;

//person객체에 age 프로퍼티가 존재한다.
//따라서 delete 연산자로 age 프로퍼티를 삭제할 수 있다.
delete person.age;

//person 객체에 address 프로퍼티가 존재하지 않는다.
//따라서 delete 연산자로 address 프로퍼티를 삭제할 수 없다. 이때 에러는 발생하지 않는다.
delete person.address;

console.log(person);
```

      



