# 객체 리터럴

#### 7. *원시타입과 객체 타입 정복하기*
###### - 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름으로 재할당을 통해 언제든지 변수 값 변경 가능 (<-> 상수: 재할당 금지 변수)
###### - 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과 

```
1) 원시타입
    ⓐ 변경 불가능한 값(변수가 아닌 값이라는 게 중요!)
    ⓑ 원시 값을 변수에 할당 -> 실제 값 저장
    ⓒ 원시 값: 숫자, 문자열, 불리언, null, undefined 등,,,

2) 객체타입
    ⓐ 변경 가능한 값
    ⓑ 객체를 변수에 할당 -> 참조 값 저장
```

#### 8. *값에 의한 전달과 참조에 의한 전달*

1) 값에 의한 전달 ( = 원시 값이 복사되어 전달된다.)
         
   **ex) 값에 의한 전달 이해하기 위한 코드** 
```javascript
let a= 10;           // 숫자 10을 a에 할당
let b = a;           // a의 값을 b에 할당
a=20;                // a의 값을 변경

console.log(a);      // 20
console.log(b);      // 10
```
**코드분석**  
① a에 저장된 실제 값 10을 복사(b는 a의 값이 복사됨)  
② a의 값이 변경되어도 b는 영향 받지 않는다.  

※ 새로운 값의 인스턴스가 생성되어 전달되므로 변수 간 변경이 서로에게 영향을 주지 않는다. 


2) 참조에 의한 전달 ( = 참조 값이 복사되어 전달된다.)

   **ex) 참조에 의한 전달 이해하기 위한 코드**  
```javascript
let a = {name:'seol};  // 객체를 a에 할당
let b = a;             // a의 참조 값을 b에 할당
a.name = 'park;        // a의 속성 변경

console.log(a.name);   // 'park'
console.log(b.name);   // 'park'
```
**코드분석**  
① a에는 객체가 할당되어 있음.
② b변수에는 a의 참조 값 즉, 객체 자체가 아닌 객체를 가리키는 참조 값(a)이 복사 (a의 참조 값을 b에 할당)
③ a와 b 모두 같은 객체를 가리킨다 -> a의 속성을 변경하면 b에도 변경이 적용된다.    

※ 변수에 저장된 값은 객체나 배열을 가리키는 참조 값이므로 이 참조 값이 복사되어 전달. 
   즉, 같은 객체를 여러 변수가 참조하기에 변수 간 변경이 해당 객체에 반영되므로 서로 간의 영향을 준다.  

   의문점 1)    
1) Q. 원시 값은 어떤 일이 있어도 불변한다고 했는데 값에 의한 전달에 의해 변경할 수 있지 않은가?  
-> A. 새로운 복사본이 생성되어 전달되는 것이지 원시 값 자체를 변경하는 게 아니다. 예시 코드를 통해 더 자세히 살펴보자.
   
   ```javascript
   let a=10;         // 원시 값은 숫자 10이고 a에 원시 값 10을 할당함.
   let b= a;         // b라는 변수를 새롭게 만들어 a를 b에 할당
   b=20;             // b 속성 변경
   console.log(a);   // 10 -> b의 값을 변경해도 a 값은 변하지 않는다.
   console.log(b);   // 20
   ```

   #### *9. *원시 값과 참조 값*

   1. 원시 값 특징
```
      1) 변수 값을 변경하기 위해 원시 값을 재할당하면 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경
```
   2. 

   
   
